export const metadata = {
  "title": "Secret Manager",
  "description": "Secure encrypted storage for API keys, tokens, and sensitive agent configuration using Cloudflare Workers secrets."
};

Secrets are a type of binding that attach sensitive data like API keys, tokens, and passwords to your Worker. Unlike environment variables, secrets are encrypted at rest and in transit, providing secure storage for sensitive configuration data that your AI agents need.

## Background

Secrets are available on the `env` parameter passed to your Worker's fetch event handler, just like environment variables. However, secrets are encrypted and designed specifically for sensitive data that should not be visible in logs or the Cloudflare dashboard after creation.

For non-sensitive configuration data like API endpoints and feature flags, use [environment variables](/en/developers/platform/environment-variables) instead of secrets.

## Add Secrets via Wrangler CLI

To add secrets using Wrangler, use the `wrangler secret` command. Secrets cannot be defined in the `wrangler.json` file for security reasons.

### Setting Secrets

```bash
# Set individual secrets
wrangler secret put OPENAI_API_KEY

# List configured secrets (values not shown)
wrangler secret list

# Delete a secret
wrangler secret delete OLD_API_KEY
```

### Environment-Specific Secrets

Set secrets for specific environments using the `--env` flag:

```bash
# Set production secrets
wrangler secret put OPENAI_API_KEY --env production

# Set staging secrets
wrangler secret put OPENAI_API_KEY --env staging
```

### Wrangler Configuration

**You must not setup env variables for secrets as they will conflcit when deploying your sevice!**

### Basic .dev.vars File

Your .dev.vars file will drive the generation of your `env.d.ts` file for static access to your secrets

```bash
# .dev.vars
# Environment variables
API_HOST=localhost:3000
ENVIRONMENT=development

# Secrets (for local development only)
OPENAI_API_KEY=sk-your-development-key-here
DATABASE_PASSWORD=dev-password-123
STRIPE_SECRET_KEY=sk_test_your-test-key-here
WEATHER_API_KEY=your-weather-api-key
```

### Agent Integration

Access secrets within your Agent class:

```typescript
// src/agents/SecureAgent.ts
import { AiAgentSDK } from '@typescript-agent-framework/core';

export class SecureAgent extends AiAgentSDK {
  constructor(env: Env) {
    super(env);
    this.validateSecrets();
  }
  
  private validateSecrets() {
    // Validate required secrets are present
    const requiredSecrets = ['OPENAI_API_KEY', 'DATABASE_PASSWORD'];
    
    for (const secret of requiredSecrets) {
      if (!this.env[secret as keyof Env]) {
        throw new Error(`Required secret ${secret} is not configured`);
      }
    }
    
    console.log('All required secrets validated');
  }
  
  async processMessage(sessionId: string, messages: AIUISDKMessage): Promise<AgentResponse> {
    // Use secrets for API calls
    if (message.content.includes('analyze')) {
      try {
        const response = await fetch('https://api.openai.com/v1/chat/completions', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${this.env.OPENAI_API_KEY}`,
            'Content-Type': 'application/json'
          },
          body: JSON.stringify({
            model: 'gpt-4',
            messages: [{ role: 'user', content: message.content }]
          })
        });
        
        if (response.status === 401) {
          return {
            message: "API authentication failed. Please check configuration.",
            error: "INVALID_API_KEY"
          };
        }
        
        const data = await response.json();
        
        return {
          message: data.choices[0].message.content,
          actions: [{
            type: 'analysis_completed',
            data: { tokensUsed: data.usage.total_tokens }
          }]
        };
        
      } catch (error) {
        console.error('OpenAI API error:', error.message); // ✅ Safe error logging
        return {
          message: "Analysis service is temporarily unavailable.",
          error: "SERVICE_UNAVAILABLE"
        };
      }
    }
    
    return { message: "I can help you analyze content. Just ask!" };
  }
}
```

### MCP Integration

Access secrets in your MCP Server:

```typescript
// src/mcp/SecureMCPServer.ts
import { MCPServerDO } from '@typescript-agent-framework/mcp';

export class SecureMCPServer extends MCPServerDO<Env> {
  constructor(state: DurableObjectState, env: Env) {
    super(state, env);
  }

  protected configureServer() {
    return {
      'fetch-weather': async ({ location }: { location: string }) => {
        // Use weather API secret
        const apiKey = this.env.WEATHER_API_KEY;
        
        if (!apiKey) {
          throw new Error('Weather API key not configured');
        }
        
        try {
          const response = await fetch(
            `https://api.openweathermap.org/data/2.5/weather?q=${location}&appid=${apiKey}`
          );
          
          if (!response.ok) {
            throw new Error(`Weather API returned ${response.status}`);
          }
          
          const data = await response.json();
          
          return {
            success: true,
            data: {
              location: data.name,
              temperature: data.main.temp,
              description: data.weather[0].description,
              humidity: data.main.humidity
            }
          };
          
        } catch (error) {
          console.error('Weather fetch error:', error.message);
          throw new Error('Failed to fetch weather data');
        }
      },
    };
  }
}
```


## Alternative Access via Node.js process.env

For Node.js compatibility, you can also access secrets through `process.env` by enabling the `nodejs_compat_populate_process_env` compatibility flag. This works the same way as environment variables.

**⚠️ Critical Limitation**: Like environment variables, `process.env` secrets are only available during runtime execution and cannot be accessed at module initialization time.

For complete details on Node.js compatibility, runtime limitations, and configuration examples, see the [Node.js process.env section in Environment Variables](/en/developers/platform/environment-variables#alternative-access-via-nodejs-processenv).


### Deploy to Specific Environments

Use the `--env` flag to deploy to specific environments which will use the specific secrets you have setup in your environment.

```bash
# Deploy to staging (uses staging secrets)
npx wrangler deploy --env staging

# Deploy to production (uses production secrets)
npx wrangler deploy --env production

# Develop with staging environment
npx wrangler dev --env staging
```

## Local Development with .dev.vars

For local development, add secrets to your `.dev.vars` file. This file should be formatted like a `dotenv` file and contains both environment variables and secrets for local development.



### Environment-Specific .dev.vars Files

Create separate `.dev.vars` files for each environment during local development:

```bash
# .dev.vars.staging
API_HOST=staging-api.example.com
ENVIRONMENT=staging
OPENAI_API_KEY=sk-your-staging-key-here
DATABASE_PASSWORD=staging-password
STRIPE_SECRET_KEY=sk_test_staging-key
```

```bash
# .dev.vars.production  
API_HOST=production-api.example.com
ENVIRONMENT=production
OPENAI_API_KEY=sk-your-production-key-here
DATABASE_PASSWORD=production-password
STRIPE_SECRET_KEY=sk_live_production-key
```

When you run `wrangler dev --env staging`, the `.dev.vars.staging` file will be loaded.

**Important:** Add `.dev.vars*` files to your `.gitignore` to prevent accidentally committing secrets:

```gitignore
# .gitignore
.dev.vars
.dev.vars.*
```

## Code Generation for Type Safety

Secrets, environment variables, and service bindings are automatically generated as TypeScript types. In any agent or MCP project, run:

```bash
npm run codegen
```

This will automatically update the `env.d.ts` file with statically generated types for:
- Environment variables from your `wrangler.json` configuration
- Secrets from your `.dev.vars` file (for development) and Wrangler configuration
- Service bindings and other Cloudflare bindings

Example generated types:

```typescript
// Generated in env.d.ts
declare namespace Cloudflare {
  interface Env {
    // Environment Variables (from wrangler.json)
    API_HOST: string;
    ENVIRONMENT: string;
    ENABLE_ANALYTICS: string;
    
    // Secrets (from .dev.vars and wrangler secrets)
    OPENAI_API_KEY: string;
    DATABASE_PASSWORD: string;
    STRIPE_SECRET_KEY: string;
    WEATHER_API_KEY: string;
    
    // Service Bindings
    USER_DB: D1Database;
    STORAGE_BUCKET: R2Bucket;
    SECURE_MCP_SERVER: DurableObjectNamespace;
  }
}

interface CloudflareEnv extends Cloudflare.Env {}
```

To ensure proper type generation:

1. Add secrets to your `.dev.vars` file for local development
2. Run `npm run codegen` to generate TypeScript types
3. Set actual secrets using `wrangler secret put` for deployed environments

## Secrets vs Environment Variables

### Use Secrets For:
- API keys and tokens
- Database passwords  
- Encryption keys
- Authentication credentials
- Payment processing keys
- Any sensitive data

### Use Environment Variables For:
- API endpoints and hostnames
- Feature flags and configuration toggles
- Non-sensitive limits and thresholds
- Environment identifiers
- Public configuration values

For non-sensitive information, use [environment variables](/en/developers/platform/environment-variables) instead of secrets. Environment variables are visible in the Cloudflare dashboard and logs.

## Practical Examples

### Multi-Service Authentication

```typescript
export interface Env {
  // Environment variables
  ENVIRONMENT: string;
  API_BASE_URL: string;
  
  // Secrets
  OPENAI_API_KEY: string;
  ANTHROPIC_API_KEY: string;
  DATABASE_PASSWORD: string;
  REDIS_AUTH_TOKEN: string;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    // Validate all required secrets are present
    const requiredSecrets = [
      'OPENAI_API_KEY',
      'ANTHROPIC_API_KEY', 
      'DATABASE_PASSWORD'
    ];
    
    for (const secret of requiredSecrets) {
      if (!env[secret as keyof Env]) {
        return new Response(`Missing required secret: ${secret}`, { status: 500 });
      }
    }
    
    // Use secrets for API calls
    const aiProviders = {
      openai: {
        url: 'https://api.openai.com/v1/chat/completions',
        headers: { 'Authorization': `Bearer ${env.OPENAI_API_KEY}` }
      },
      anthropic: {
        url: 'https://api.anthropic.com/v1/messages',
        headers: { 'x-api-key': env.ANTHROPIC_API_KEY }
      }
    };
    
    return new Response('Services configured successfully');
  },
};
```

### Secure Database Connection

```typescript
export interface Env {
  DATABASE_URL: string;
  DATABASE_PASSWORD: string;
  ENCRYPTION_KEY: string;
}

async function connectToDatabase(env: Env) {
  // Build connection string with secret password
  const connectionString = `${env.DATABASE_URL}?password=${env.DATABASE_PASSWORD}`;
  
  try {
    // Connect using the secret
    const db = await createConnection(connectionString);
    
    // Use encryption key for sensitive data
    const encryptionKey = env.ENCRYPTION_KEY;
    
    return { db, encryptionKey };
  } catch (error) {
    console.error('Database connection failed'); // Don't log the actual error with credentials
    throw new Error('Database connection failed');
  }
}
```

### Payment Processing

```typescript
export interface Env {
  STRIPE_SECRET_KEY: string;
  STRIPE_WEBHOOK_SECRET: string;
  PAYPAL_CLIENT_SECRET: string;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const url = new URL(request.url);
    
    if (url.pathname === '/create-payment-intent') {
      const { amount, currency } = await request.json();
      
      try {
        const response = await fetch('https://api.stripe.com/v1/payment_intents', {
          method: 'POST',
          headers: {
            'Authorization': `Bearer ${env.STRIPE_SECRET_KEY}`,
            'Content-Type': 'application/x-www-form-urlencoded'
          },
          body: new URLSearchParams({
            amount: (amount * 100).toString(),
            currency: currency.toLowerCase()
          })
        });
        
        if (!response.ok) {
          throw new Error('Stripe API error');
        }
        
        const paymentIntent = await response.json();
        
        return new Response(JSON.stringify({
          clientSecret: paymentIntent.client_secret
        }), {
          headers: { 'Content-Type': 'application/json' }
        });
        
      } catch (error) {
        console.error('Payment processing failed');
        return new Response('Payment processing failed', { status: 500 });
      }
    }
    
    if (url.pathname === '/stripe-webhook') {
      // Verify webhook signature using secret
      const signature = request.headers.get('stripe-signature');
      const body = await request.text();
      
      try {
        const isValid = verifyStripeSignature(
          body,
          signature,
          env.STRIPE_WEBHOOK_SECRET
        );
        
        if (!isValid) {
          return new Response('Invalid signature', { status: 400 });
        }
        
        // Process webhook
        return new Response('Webhook processed', { status: 200 });
        
      } catch (error) {
        console.error('Webhook verification failed');
        return new Response('Webhook verification failed', { status: 400 });
      }
    }
    
    return new Response('Not found', { status: 404 });
  },
};
```

### Environment-Aware Secret Usage

```typescript
export interface Env {
  ENVIRONMENT: string;
  OPENAI_API_KEY: string;
  DATABASE_PASSWORD: string;
  SENTRY_DSN: string;
}

export default {
  async fetch(request: Request, env: Env): Promise<Response> {
    const isProduction = env.ENVIRONMENT === 'production';
    const isDevelopment = env.ENVIRONMENT === 'development';
    
    // Configure error reporting with secret DSN
    if (isProduction && env.SENTRY_DSN) {
      // Initialize Sentry for production error tracking
      initSentry(env.SENTRY_DSN);
    }
    
    // Use different API configurations per environment
    const openaiConfig = {
      apiKey: env.OPENAI_API_KEY,
      model: isProduction ? 'gpt-4' : 'gpt-3.5-turbo', // Use cheaper model in dev
      maxTokens: isProduction ? 4000 : 1000 // Limit tokens in dev
    };
    
    // Database configuration with secrets
    const dbConfig = {
      password: env.DATABASE_PASSWORD,
      maxConnections: isProduction ? 20 : 5,
      timeout: isProduction ? 30000 : 10000,
      ssl: isProduction // Only require SSL in production
    };
    
    return new Response(`Configured for ${env.ENVIRONMENT}`);
  },
};
```

## Best Practices

### Security Guidelines

```typescript
// ✅ Good: Never log secret values
try {
  const apiKey = env.OPENAI_API_KEY;
  console.log('API key configured:', !!apiKey); // ✅ Safe logging
  console.log('API key length:', apiKey?.length); // ✅ Safe metadata
} catch (error) {
  console.error('Failed to load API key:', error.message); // ✅ Safe error logging
}

// ❌ Bad: Logging secret values
const apiKey = env.OPENAI_API_KEY;
console.log('API Key:', apiKey); // ❌ Exposes secret in logs
console.error('API error with key:', apiKey); // ❌ Secret in error logs
```

### Error Handling

```typescript
// ✅ Good: Graceful handling of missing secrets
async function safeApiCall(env: Env, prompt: string) {
  if (!env.OPENAI_API_KEY) {
    throw new Error('OpenAI API key not configured');
  }
  
  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Authorization': `Bearer ${env.OPENAI_API_KEY}`,
        'Content-Type': 'application/json'
      },
      body: JSON.stringify({ model: 'gpt-4', messages: [{ role: 'user', content: prompt }] })
    });
    
    if (response.status === 401) {
      throw new Error('Invalid API key');
    }
    
    return await response.json();
  } catch (error) {
    console.error('API call failed:', error.message); // Don't log the actual key
    throw new Error('AI service unavailable');
  }
}
```

## Security Features

- **Encryption**: AES-256 encryption at rest, TLS 1.3 in transit
- **Access Control**: Secrets are only accessible to your code at runtime
- **Audit Trail**: Secret creation and deletion are logged
- **Zero Visibility**: Secret values are never visible after creation
- **Environment Isolation**: Secrets are isolated per environment

## Limitations

- **Secret Size**: Maximum 25KB per secret value
- **Secret Count**: Maximum 100 secrets per Worker
- **Naming**: Secret names must be valid environment variable names
- **CLI Only**: Secrets can only be set via Wrangler CLI

## Related Services

- **[Environment Variables](/en/developers/platform/environment-variables)** - Non-sensitive configuration
- **[Memory Store](/en/developers/platform/memory-store)** - Temporary sensitive data storage  
- **[Analytics Storage](/en/developers/platform/analytics-storage)** - Audit logging and monitoring

---

## Official Documentation

- [Cloudflare Workers Secrets](https://developers.cloudflare.com/workers/configuration/secrets/)
- [Wrangler Secret Commands](https://developers.cloudflare.com/workers/wrangler/commands/#secret) 