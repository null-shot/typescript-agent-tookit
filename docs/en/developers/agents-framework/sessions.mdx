export const metadata = {
  "title": "Sessions",
  "description": "Managing user sessions and routing conversations with Hono and Durable Objects"
};

Sessions enable you to maintain conversation context across multiple interactions. Every agent conversation gets its own unique session powered by Cloudflare Durable Objects, giving you persistent, stateful conversations that scale automatically.

## The Magic: Durable Objects

The **key insight** is that each session maps to a unique Durable Object instance. When you route to `/agent/chat/abc123`, you're talking to the same persistent object every time. This is where the magic happens - your conversation state, memory, and context live in that specific instance.

```typescript
// This is the core pattern - route to a unique AGENT instance
const agent = AGENT.get(id); // Gets the specific Durable Object for this session
```

## Quick Start: Default Router

The simplest setup uses our default Hono router. It automatically handles session IDs and routes to the right agent instance:

```typescript
import { Hono } from 'hono';
import { applyPermissionlessAgentSessionRouter } from '@nullshot/agent';
import { MyAgent } from './agents/my-agent';

// Use type assertion to make Hono app compatible with AgentRouterBuilder
const app = new Hono<{ Bindings: EnvWithAgent }>();
applyPermissionlessAgentSessionRouter(app);

export default {
  fetch: app.fetch,
};
```

**That's it!** You now have:
- `POST /agent/chat/:sessionId` - Send messages to a specific session (a sessionId is generated for you on the first message)
- Automatic Durable Object routing
- Persistent conversation state

## How Session Routing Works

The router implementation ([source](https://github.com/null-shot/typescript-agent-framework/blob/main/packages/agent/src/router.ts)) follows this pattern:

1. **Extract session ID** from the URL path (`/agent/chat/abc123`)
2. **Generate Durable Object ID** from the session ID  
3. **Route to specific agent instance** using `AGENT.get(id)`
4. **Maintain conversation state** in that persistent object

```typescript
// Simplified router logic
app.post('/chat/:sessionId', async (c) => {
  const sessionId = c.req.param('sessionId');
  const id = env.AGENT.idFromName(sessionId); // Create consistent DO ID
  const agent = env.AGENT.get(id); // Get the persistent instance
  return agent.fetch(c.req.raw); // Route to the agent
});
```

## Custom Routers

You don't need the default router. Here's a minimal custom implementation ([example](https://github.com/null-shot/typescript-agent-template/blob/main/src/index.ts)):

```typescript
import { Hono } from 'hono';

const app = new Hono<{ Bindings: Env }>();

app.post('/chat/:sessionId', async (c) => {
  const sessionId = c.req.param('sessionId');
  
  // Create Durable Object ID from session
  const id = c.env.AGENT.idFromName(sessionId);
  const agent = c.env.AGENT.get(id);
  
  // Forward the request to the agent
  return agent.fetch(c.req.raw);
});

export default {
  fetch: app.fetch,
};
```

## The Agent Implementation

Your actual agent ([source](https://github.com/null-shot/typescript-agent-framework/blob/main/packages/agent/src/agent.ts)) runs inside the Durable Object:

```typescript
export class MyAgent extends AiSdkAgent<Env> {
  constructor(state: DurableObjectState, env: Env, model: LanguageModel) {
    super(state, env, model);
  }

  async processMessage(sessionId: string, messages: AIUISDKMessage): Promise<Response> {
    // This is where the magic happens - persistent conversation state
    const result = await this.streamTextWithMessages(sessionId, messages.messages, {
      system: 'You are a helpful assistant.',
      maxSteps: 5,
      stopWhen: stepCountIs(5),
      experimental_toolCallStreaming: true,
    });

    return result.toTextStreamResponse();
  }
}
```

## Key Points

### ✅ Do This
- **Always route to AGENT.get(id)** - This is crucial for persistence
- **Use meaningful session IDs** - They become Durable Object names
- **Let the framework handle state** - It's built for this

### ❌ Avoid This
- Don't try to manage state outside the agent
- Don't create new Durable Object IDs for the same session
- Don't skip the routing layer - it handles the magic and will be key for future protocol and permission use cases

## Production Patterns

### Health Checks
```typescript
app.get('/health', (c) => {
  return c.json({ status: 'ok', timestamp: Date.now() });
});
```

### Session Management API
```typescript
app.get('/sessions/:userId', async (c) => {
  const userId = c.req.param('userId');
  
  // Get user's sessions from database
  const sessions = await c.env.DB.prepare(
    'SELECT id, created_at, last_activity FROM sessions WHERE user_id = ?'
  ).bind(userId).all();
  
  return c.json(sessions);
});
```

### Session Cleanup
```typescript
app.delete('/sessions/:sessionId', async (c) => {
  const sessionId = c.req.param('sessionId');
  
  // Clean up database record
  await c.env.DB.prepare(
    'DELETE FROM sessions WHERE id = ?'
  ).bind(sessionId).run();
  
  // The Durable Object will be cleaned up automatically by Cloudflare
  return c.json({ message: 'Session deleted' });
});
```

## Next Steps

- **[Agent SDK](./agent-sdk)** - Build your agent logic
- **[AI SDK Integration](./ai-sdk)** - Add AI models to your agents  
- **[Platform Services](../platform/overview)** - Storage, analytics, and more

Remember: The session is just a routing mechanism. The real magic happens inside your Durable Object agent instance. Keep it simple, let the framework handle the complexity, and focus on building great conversational experiences! 🚀 